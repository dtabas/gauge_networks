import numpy as np
import cvxpy as cp
import scipy.linalg
import scipy.optimize
import matplotlib.pyplot as plt
from itertools import permutations
from pytope import Polytope
import invariant_set

# Interior point generated by propogating an interior point function for a
# single-step MPC through the dynamics

# Need invariant set for feasibility

#%% Linear feedback

def generate_sys_params(tau=5):
        
    n = 3 # number of states
    m = 2 # number of controls
    
    wb = .1 # max disturbance magnitude
    x0b = wb # max magnitude of initial state
    x0_bar = x0b * np.ones((n,1))
    Ad =  np.array([[-.5,.3,-1],[.2,-.5,.6],[1,.6,-.6]]) # Discrete time state transition matrix
    Bd = np.array([[-.601,-.890],[.955,-.715],[.246,-.184]]) # Discrete time input-to-state matrix
    
    u_bar = 1 * np.ones((m,1))
    x_bar = 5 * np.ones((n,1))
    w_bar = wb * np.ones((n,1))
    
    # Constraints on parameter (x0):
    J = np.block([[np.eye(n)],[-np.eye(n)]])
    j = np.tile(x0_bar,(2,1))    
    
    # Vertices of constraint set:
    r = 3
    X0_vertices = np.array(list(set(permutations(list((J@x0_bar).flatten()),r=r)))).T
    
    Pt,bt,Pr,br,K = invariant_set.generate_invariant_set(Ad,Bd,np.eye(n),np.eye(n),np.eye(m),np.eye(n),x_bar,u_bar,w_bar,15)
        
    return tau,n,m,wb,x0b,x0_bar,Ad,Bd,r,u_bar,x_bar,J,j,X0_vertices,Pt,bt,Pr,br,K

def generate_MPC_params(sys_params):
    
    # Generate the block matrices defining the system dynamics and constraints on time horizon tau.

    T,n,m,wb,x0b,x0_bar,Ad,Bd,r,u_bar,x_bar,J,j,X0_vertices,Pt,bt,Pr,br,K = sys_params
    
    z_nm = np.zeros((n,m))
    z_nn = np.zeros((n,n))
    
    # Trajectory matrices:
    Mu = [[z_nm for i in range(T)] for j in range(T)]
    Mw = [[z_nn for i in range(T)] for j in range(T)]
    M0 = [z_nn for i in range(T)]
    for i in range(1,T+1):
        M0[i-1] = np.linalg.matrix_power(Ad,i)
        for j in range(1,i+1):
            Mu[i-1][j-1] = np.linalg.matrix_power(Ad,i-j) @ Bd
            Mw[i-1][j-1] = np.linalg.matrix_power(Ad,i-j) @ np.eye(n)
    Mu = np.block(Mu)
    Mw = np.block(Mw)
    M0 = np.vstack(M0)
    
    # Inequality constraints:
    Fx = scipy.linalg.block_diag(*[Pt]*T)
    gx = np.vstack([bt]*T)
    Fu = np.vstack((np.eye(m*T),-np.eye(m*T)))
    gu = np.tile(u_bar,(2*T,1))
    F = np.block([[Fx@Mu],[Fu]])
    g = np.vstack((gx,gu))
    H0 = np.vstack((-Fx@M0,np.zeros((2*m*T,n))))
    Hw = np.vstack((-Fx@Mw,np.zeros((2*m*T,n*T))))
        
    return Mu,Mw,M0,F,g,H0,Hw

def IP_affine(sys_params,MPC_params):
    
    # Generate affine function that returns an interior point of the one-step feasible set, for any initial condition (if such a function exists)

    T,n,m,wb,x0b,x0_bar,Ad,Bd,r,u_bar,x_bar,J,j,X0_vertices,Pt,bt,Pr,br,K = sys_params
    Mu,Mw,M0,F,g,H0,Hw = MPC_params
    
    # Interior point from linear feedback using halfspace form:
    Fu1 = np.block([[np.eye(m)],[-np.eye(m)]])
    gu1 = np.vstack((u_bar,u_bar))
    Fx1 = Pt #np.block([[np.eye(n)],[-np.eye(n)]])
    gx1 = bt #np.vstack((x_bar,x_bar))
    Fp1 = Pr #J
    gp1 = br #j
    s = cp.Variable()
    W = cp.Variable((m,n))
    w = cp.Variable((m,1))
    
    Fp2s = cp.bmat([[Fu1@W],[Fx1@(Ad + Bd@W)]])
    
    Y = cp.Variable((np.shape(Fp2s)[0],np.shape(gp1)[0]))
    
    gp2s = cp.bmat([[gu1 - Fu1@w],[gx1 - Fx1@Bd@w]]) + s
    constraints = [Y >= 0,
                   Y@gp1 <= gp2s,
                   Y@Fp1 == Fp2s]
    obj = cp.Minimize(s)
    prob1 = cp.Problem(obj,constraints)
    prob1.solve(solver = cp.SCS)
    assert prob1.value < 0
    #print('value: ' + str(prob1.value))
        
    return W.value,w.value #,Fp2s.value,gp2s.value

def generate_M_ip(sys_params,W,w):
    
    # Generate affine function that returns an interior point of the MPC feasible set on time horizon tau, for any initial condition (if such a function exists)
    
    tau,n,m,wb,x0b,x0_bar,Ad,Bd,r,u_bar,x_bar,J,j,X0_vertices,Pt,bt,Pr,br,K = sys_params
    Mu_ip = [np.zeros((m,n)) for i in range(tau)]
    mu_ip = [np.zeros((m,1)) for i in range(tau)]
    A_tilde = Ad + Bd@W
    c = Bd@w
    for i in range(0,tau):
        Mu_ip[i] = W@np.linalg.matrix_power(A_tilde,i)
        d = np.zeros((n,1))
        for j in range(i): d += np.linalg.matrix_power(A_tilde,j)@c
        mu_ip[i] = w + W@d
    Mu_ip = np.vstack(Mu_ip)
    mu_ip = np.vstack(mu_ip)
    
    return Mu_ip,mu_ip

if __name__ == '__main__':
    
    sys_params = generate_sys_params(tau=10)
    T,n,m,wb,x0b,x0_bar,Ad,Bd,r,u_bar,x_bar,J,j,X0,Pt,bt,Pr,br,K = sys_params
    MPC_params = generate_MPC_params(sys_params)
    Mu,Mw,M0,F,g,H0,Hw = MPC_params
    W,w = IP_affine(sys_params,MPC_params)
    
    #X0 = np.random.uniform(low=-x0_bar,high=x0_bar,size=(n,200))
    X0 = (Polytope(Pr,br).V).T
        
    sh = []
    Mu_ip,mu_ip = generate_M_ip(sys_params,W,w)
    for x0 in list(X0.T):
        x0 = np.reshape(x0,(n,1))
        Y_hat =  Mu_ip @ x0 + mu_ip
        rh = F@Y_hat - g - H0@x0
        sh.append(np.max(rh,axis = 0)[0])
    
    # Check ground truth:
    q = np.shape(X0)[1]    
    s_star = []
    for i in range(q):
        X = cp.Variable((m*T,1))
        s = cp.Variable()
        constraints = [F@X <= g + H0@np.reshape(X0[:,i],(n,1)) + np.ones((np.shape(F)[0],1))*s]
        obj = cp.Minimize(s)
        prob3 = cp.Problem(obj,constraints)
        prob3.solve(solver=cp.SCS)
        s_star.append(prob3.value)
        #print(i)
        
    s_sorted = sorted(zip(s_star,sh),key=lambda pair: pair[0])
        
    plt.figure()
    plt.step(range(len(s_sorted)),s_sorted)
    plt.xlabel('Vertex number')
    plt.ylabel('Maximum constraint violation')
    #plt.legend()
    plt.plot([1,q],[0,0],'--k')
    plt.legend(['Optimal','Affine function'])
    
    #print(s_sorted[-1])